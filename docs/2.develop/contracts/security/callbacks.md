---
id: callbacks
title: 교차 컨트랙트 호출
---

교차 컨트랙트 호출을 작성하는 동안 명심해야 할 중요한 측면이 있습니다. 모든 호출은 **독립적**이고 **비동기적**입니다. 다시 말해서:


- 호출 메서드와 콜백 메서드는 **독립적**입니다.
- 호출과 콜백 사이에서 사람들은 컨트랙트와 상호 작용할 수 있습니다.

이는 콜백을 처리하는 방법에 중요한 영향을 미칩니다. 특히:

1. 콜백 메서드는 공개되어야 하지만, 이를 컨트랙트만 호출할 수 있도록 할 수 있습니다.
2. 호출과 콜백 사이에 컨트랙트를 악용 가능한 상태로 두지 않아야 합니다.
3. 외부 호출이 실패한 경우, 콜백의 상태에 대한 모든 변경 사항을 수동으로 롤백해야 합니다.
---

## 프라이빗 콜백
교차 컨트랙트 호출이 완료될 때, 컨트랙트가 자체적으로 호출되도록 하려면 콜백 메서드를 공개해야 합니다. 그러나 대부분의 경우 공개되지 않길 원할 것입니다. `predecessor`이 `current_account`임을 assert하여, 메서드를 퍼블릭으로 유지하면서 비공개로 만들 수 있습니다. Rust에서는 `#[private]` 데코레이터를 추가하면 이 작업이 자동으로 수행됩니다.


---

## 사용자의 자금
메서드가 패닉 상태가 되면, 해당 트랜잭션에 첨부된 돈이 `predecessor`에게 반환됩니다. 즉, 교차 컨트랙트 호출을 하고 실패하면, 돈이 **컨트랙트로 돌아갑니다**. 컨트랙트를 호출한 사용자로부터 돈이 나온 경우, 콜백 도중에 이를 반환해야 합니다.


![img](https://miro.medium.com/max/1400/1*Hp4TOcaBqm9LS0wkgWw3nA.png)
*사용자가 돈을 첨부한 경우, 콜백에서 수동으로 반환해야 합니다*

:::caution
전송 작업을 위해 콜백에 충분한 가스가 있는지 확인하세요.
:::

---

## 비동기 콜백
교차 컨트랙트 호출과 콜백 사이에서 **컨트랙트의 모든 메서드를 실행할 수 있습니다**. 이것을 고려하지 않는 것은 해킹의 주요 원인 중 하나입니다. 재진입 공격이라는 자체 이름이 있을 정도로, 이는 매우 기본적인 해킹 방식입니다.

다음과 같은 **잘못된 로직**으로 `deposit_and_stake`를 개발한다고 상상해 봅시다. (1) 사용자가 우리에게 돈을 보냅니다. (2) 우리는 이를 잔고에 추가합니다. (3) 밸리데이터에 스테이킹을 시도합니다. (4) 스테이킹이 실패하면, 콜백에서 잔고를 제거합니다. 그러면, 사용자는 (2)와 (4) 사이에 호출을 철회하도록 예약할 수 있으며, 스테이킹에 실패하면 사용자는 두 번 돈을 받게 됩니다.

![img](https://miro.medium.com/max/1400/1*VweWHQYGLBa70uceiWHLQA.png)
*교차 컨트랙트 호출과 콜백 사이에 무슨 일이든 일어날 수 있습니다*

다행스럽게도 솔루션은 다소 간단합니다. 사용자의 잔고에 돈을 즉시 추가하는 대신, 콜백이 올 때까지 기다립니다. 그런 다음, 확인 후 스테이킹이 잘 되었으면 잔고에 추가하면 됩니다.


![img](https://miro.medium.com/max/1400/1*o0YVDCp_7l-L3njJMGhU4w.png)
*교차 컨트랙트 호출에서 예금을 처리하는 올바른 방법*